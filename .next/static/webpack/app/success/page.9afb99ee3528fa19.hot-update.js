"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/success/page",{

/***/ "(app-pages-browser)/./src/utils/fileSystemAccess.ts":
/*!***************************************!*\
  !*** ./src/utils/fileSystemAccess.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadJsonFile: function() { return /* binding */ downloadJsonFile; },\n/* harmony export */   downloadMarkdownFile: function() { return /* binding */ downloadMarkdownFile; },\n/* harmony export */   isBrowser: function() { return /* binding */ isBrowser; },\n/* harmony export */   isFileSystemAccessSupported: function() { return /* binding */ isFileSystemAccessSupported; },\n/* harmony export */   isVercelEnv: function() { return /* binding */ isVercelEnv; },\n/* harmony export */   saveConversationToObsidianVault: function() { return /* binding */ saveConversationToObsidianVault; },\n/* harmony export */   saveFileWithPicker: function() { return /* binding */ saveFileWithPicker; },\n/* harmony export */   saveFilesToDirectory: function() { return /* binding */ saveFilesToDirectory; },\n/* harmony export */   verifyPermission: function() { return /* binding */ verifyPermission; }\n/* harmony export */ });\n/**\r\n * File System Access API 지원 여부를 확인합니다.\r\n */ function isFileSystemAccessSupported() {\n    return  true && \"showSaveFilePicker\" in window && \"showDirectoryPicker\" in window;\n}\n/**\r\n * 브라우저 환경인지 확인합니다.\r\n */ function isBrowser() {\n    return \"object\" !== \"undefined\";\n}\n/**\r\n * Vercel 배포 환경에서 실행 중인지 확인합니다.\r\n * 클라이언트, 서버 사이드 모두에서 안정적으로 동작하도록 수정\r\n */ function isVercelEnv() {\n    // 서버 사이드에서의 확인\n    if (false) {}\n    // 클라이언트 사이드에서의 확인\n    try {\n        // window.location.hostname으로 확인 (클라이언트 사이드)\n        const hostname = window.location.hostname;\n        return hostname.includes(\"vercel.app\") || hostname.endsWith(\".vercel.app\") || // 다른 프로덕션 도메인들\n        hostname === \"pmkproject.site\" || hostname === \"www.pmkproject.site\";\n    } catch (error) {\n        console.error(\"Error checking Vercel environment on client side:\", error);\n        // 에러 발생 시 안전하게 true 반환 (배포 환경으로 취급)\n        return true;\n    }\n}\n/**\r\n * 파일 시스템 쓰기 권한을 확인합니다.\r\n */ async function verifyPermission(fileHandle) {\n    let readWrite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const options = {};\n    if (readWrite) {\n        options.mode = \"readwrite\";\n    }\n    // 이미 권한이 있는지 확인\n    if (await fileHandle.queryPermission(options) === \"granted\") {\n        return true;\n    }\n    // 권한 요청\n    if (await fileHandle.requestPermission(options) === \"granted\") {\n        return true;\n    }\n    return false;\n}\n/**\r\n * 파일 저장 다이얼로그를 표시하고 파일을 저장합니다.\r\n */ async function saveFileWithPicker(content) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (!isFileSystemAccessSupported()) {\n        console.error(\"File System Access API가 지원되지 않는 브라우저입니다.\");\n        return false;\n    }\n    const { fileName = \"untitled\", fileExtension = \".txt\", description = \"Text documents\", startIn = \"documents\", mimeType = \"text/plain\" } = options;\n    const suggestedName = fileName.endsWith(fileExtension) ? fileName : \"\".concat(fileName).concat(fileExtension);\n    try {\n        // 파일 저장 다이얼로그 표시\n        const handle = await window.showSaveFilePicker({\n            suggestedName,\n            types: [\n                {\n                    description,\n                    accept: {\n                        [mimeType]: [\n                            fileExtension\n                        ]\n                    }\n                }\n            ],\n            startIn\n        });\n        // 파일 쓰기 권한 확인\n        const hasPermission = await verifyPermission(handle, true);\n        if (!hasPermission) {\n            throw new Error(\"파일 쓰기 권한이 거부되었습니다.\");\n        }\n        // 파일 쓰기 스트림 생성\n        const writable = await handle.createWritable();\n        // 데이터 쓰기\n        await writable.write(content);\n        // 스트림 닫기\n        await writable.close();\n        return true;\n    } catch (error) {\n        console.error(\"파일 저장 중 오류:\", error);\n        return false;\n    }\n}\n/**\r\n * 디렉토리 선택 다이얼로그를 표시하고 선택된 디렉토리에 파일을 저장합니다.\r\n */ async function saveFilesToDirectory(files) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (!isFileSystemAccessSupported()) {\n        console.error(\"File System Access API가 지원되지 않는 브라우저입니다.\");\n        return {\n            success: false,\n            savedFiles: []\n        };\n    }\n    const { startIn = \"documents\" } = options;\n    try {\n        // 디렉토리 선택 다이얼로그 표시\n        const dirHandle = await window.showDirectoryPicker({\n            startIn,\n            id: \"obsidian-vault-selector\",\n            mode: \"readwrite\"\n        });\n        // 디렉토리 쓰기 권한 확인\n        const hasPermission = await verifyPermission(dirHandle, true);\n        if (!hasPermission) {\n            throw new Error(\"디렉토리 쓰기 권한이 거부되었습니다.\");\n        }\n        const savedFiles = [];\n        // 각 파일 저장\n        for (const file of files){\n            try {\n                let targetDir = dirHandle;\n                // 하위 폴더가 지정된 경우 해당 폴더 생성 또는 접근\n                if (file.subFolder) {\n                    const subFolders = file.subFolder.split(\"/\");\n                    for (const folder of subFolders){\n                        if (!folder) continue;\n                        targetDir = await targetDir.getDirectoryHandle(folder, {\n                            create: true\n                        });\n                    }\n                }\n                // 파일 핸들 생성\n                const fileHandle = await targetDir.getFileHandle(file.name, {\n                    create: true\n                });\n                // 파일 쓰기 스트림 생성\n                const writable = await fileHandle.createWritable();\n                // 데이터 쓰기\n                await writable.write(file.content);\n                // 스트림 닫기\n                await writable.close();\n                // 저장된 파일 경로 추가\n                savedFiles.push(file.subFolder ? \"\".concat(file.subFolder, \"/\").concat(file.name) : file.name);\n            } catch (fileError) {\n                console.error(\"파일 저장 중 오류 (\".concat(file.name, \"):\"), fileError);\n            }\n        }\n        return {\n            success: savedFiles.length > 0,\n            savedFiles\n        };\n    } catch (error) {\n        console.error(\"디렉토리 저장 중 오류:\", error);\n        return {\n            success: false,\n            savedFiles: []\n        };\n    }\n}\n/**\r\n * 옵시디언 볼트에 대화 내용을 저장합니다.\r\n */ async function saveConversationToObsidianVault(conversation, summaryResult, rawText, url) {\n    if (!isFileSystemAccessSupported()) {\n        console.error(\"File System Access API가 지원되지 않는 브라우저입니다.\");\n        return {\n            success: false,\n            files: []\n        };\n    }\n    try {\n        var _conversation_metadata, _conversation_metadata1, _conversation_metadata2;\n        // 파일명 생성 (제목을 파일명으로 변환)\n        const baseFileName = conversation.title.toLowerCase().replace(/[^a-z0-9가-힣]/g, \"-\").replace(/-+/g, \"-\").replace(/^-|-$/g, \"\").substring(0, 100);\n        const markdownFileName = \"\".concat(baseFileName, \".md\");\n        const textFileName = \"\".concat(baseFileName, \"-original.txt\");\n        const jsonFileName = \"\".concat(baseFileName, \"-\").concat(Date.now(), \".json\");\n        // 태그 목록 준비 (요약에서 추출한 키워드 + ChatGPT 모델)\n        const tags = [\n            ...summaryResult.keywords || [],\n            ((_conversation_metadata = conversation.metadata) === null || _conversation_metadata === void 0 ? void 0 : _conversation_metadata.model) || summaryResult.modelUsed || \"gpt-4.1-nano\"\n        ].filter(Boolean); // 빈 값 제거\n        // YAML 프론트매터 생성\n        const frontmatter = \"---\\ntitle: \".concat(conversation.title, \"\\ndate: \").concat(new Date().toISOString(), \"\\nsource: \").concat(url, \"\\ntags: [\").concat(tags.map((tag)=>'\"'.concat(tag, '\"')).join(\", \"), \"]\\nmodel: \").concat(((_conversation_metadata1 = conversation.metadata) === null || _conversation_metadata1 === void 0 ? void 0 : _conversation_metadata1.model) || summaryResult.modelUsed || \"gpt-4.1-nano\", \"\\n---\\n\\n\");\n        // 대화 내용을 마크다운으로 변환\n        let markdownContent = frontmatter;\n        // 대화 내용 추가\n        markdownContent += \"# \".concat(conversation.title, \"\\n\\n\");\n        // URL과 날짜 정보 추가\n        markdownContent += \"> [원본 URL](\".concat(url, \")\\n\\n\");\n        markdownContent += \"> 저장 시간: \".concat(new Date().toLocaleString(\"ko-KR\"), \"\\n\\n\");\n        if (tags.length > 0) {\n            markdownContent += \"> 태그: \".concat(tags.join(\", \"), \"\\n\\n\");\n        }\n        markdownContent += \"---\\n\\n\";\n        // 사용자-어시스턴트 대화 내용을 마크다운으로 포맷팅\n        conversation.messages.forEach((message, index)=>{\n            const isUser = message.role === \"user\";\n            const messageHeader = isUser ? \"## \\uD83D\\uDC64 사용자\" : \"## \\uD83E\\uDD16 assistant\";\n            // 역할과 내용을 구분하여 표시\n            markdownContent += \"\".concat(messageHeader, \"\\n\\n\").concat(message.content, \"\\n\\n\");\n            // 마지막 메시지가 아니면 구분선 추가\n            if (index < conversation.messages.length - 1) {\n                markdownContent += \"---\\n\\n\";\n            }\n        });\n        // 요약 섹션 추가\n        markdownContent += \"\\n\\n---\\n\\n## \\uD83D\\uDCA1 요약\\n\\n\".concat(summaryResult.summary, \"\\n\");\n        // 키워드 섹션 추가\n        if (summaryResult.keywords && summaryResult.keywords.length > 0) {\n            markdownContent += \"\\n## \\uD83D\\uDD11 키워드\\n\\n\".concat(summaryResult.keywords.map((k)=>\"`\".concat(k, \"`\")).join(\" \"), \"\\n\");\n        }\n        // JSON 파일 내용 생성\n        const jsonContent = JSON.stringify({\n            title: conversation.title,\n            url,\n            summary: summaryResult.summary,\n            keywords: summaryResult.keywords,\n            messages: conversation.messages,\n            metadata: {\n                ...conversation.metadata || {},\n                model: ((_conversation_metadata2 = conversation.metadata) === null || _conversation_metadata2 === void 0 ? void 0 : _conversation_metadata2.model) || summaryResult.modelUsed || \"gpt-4.1-nano\",\n                savedAt: new Date().toISOString()\n            },\n            createdAt: new Date().toISOString()\n        }, null, 2);\n        // 파일 저장할 준비\n        const files = [\n            {\n                name: markdownFileName,\n                content: markdownContent,\n                subFolder: \"ChatGPT\"\n            },\n            {\n                name: textFileName,\n                content: rawText,\n                subFolder: \"ChatGPT\"\n            },\n            {\n                name: jsonFileName,\n                content: jsonContent,\n                subFolder: \"_data/conversations\"\n            }\n        ];\n        // 디렉토리 선택 다이얼로그 표시 및 파일 저장\n        const result = await saveFilesToDirectory(files, {\n            startIn: \"documents\"\n        });\n        return {\n            success: result.success,\n            files: result.savedFiles\n        };\n    } catch (error) {\n        console.error(\"옵시디언 저장 중 오류:\", error);\n        return {\n            success: false,\n            files: []\n        };\n    }\n}\n/**\r\n * 대화 내용을 마크다운 파일로 다운로드합니다.\r\n */ function downloadMarkdownFile(conversation, summaryResult, url) {\n    var _conversation_metadata, _conversation_metadata1;\n    if (!isBrowser()) return;\n    // 태그 목록 준비 (요약에서 추출한 키워드 + ChatGPT 모델)\n    const tags = [\n        ...summaryResult.keywords || [],\n        ((_conversation_metadata = conversation.metadata) === null || _conversation_metadata === void 0 ? void 0 : _conversation_metadata.model) || summaryResult.modelUsed || \"gpt-4.1-nano\"\n    ].filter(Boolean); // 빈 값 제거\n    // YAML 프론트매터 생성\n    const frontmatter = \"---\\ntitle: \".concat(conversation.title, \"\\ndate: \").concat(new Date().toISOString(), \"\\nsource: \").concat(url, \"\\ntags: [\").concat(tags.map((tag)=>'\"'.concat(tag, '\"')).join(\", \"), \"]\\nmodel: \").concat(((_conversation_metadata1 = conversation.metadata) === null || _conversation_metadata1 === void 0 ? void 0 : _conversation_metadata1.model) || summaryResult.modelUsed || \"gpt-4.1-nano\", \"\\n---\\n\\n\");\n    // 대화 내용을 마크다운으로 변환\n    let markdownContent = frontmatter;\n    // 대화 내용 추가\n    markdownContent += \"# \".concat(conversation.title, \"\\n\\n\");\n    // URL과 날짜 정보 추가\n    markdownContent += \"> [원본 URL](\".concat(url, \")\\n\\n\");\n    markdownContent += \"> 저장 시간: \".concat(new Date().toLocaleString(\"ko-KR\"), \"\\n\\n\");\n    if (tags.length > 0) {\n        markdownContent += \"> 태그: \".concat(tags.join(\", \"), \"\\n\\n\");\n    }\n    markdownContent += \"---\\n\\n\";\n    // 사용자-어시스턴트 대화 내용을 마크다운으로 포맷팅\n    conversation.messages.forEach((message, index)=>{\n        const isUser = message.role === \"user\";\n        const messageHeader = isUser ? \"## \\uD83D\\uDC64 사용자\" : \"## \\uD83E\\uDD16 assistant\";\n        // 역할과 내용을 구분하여 표시\n        markdownContent += \"\".concat(messageHeader, \"\\n\\n\").concat(message.content, \"\\n\\n\");\n        // 마지막 메시지가 아니면 구분선 추가\n        if (index < conversation.messages.length - 1) {\n            markdownContent += \"---\\n\\n\";\n        }\n    });\n    // 요약 섹션 추가\n    markdownContent += \"\\n\\n---\\n\\n## \\uD83D\\uDCA1 요약\\n\\n\".concat(summaryResult.summary, \"\\n\");\n    // 키워드 섹션 추가\n    if (summaryResult.keywords && summaryResult.keywords.length > 0) {\n        markdownContent += \"\\n## \\uD83D\\uDD11 키워드\\n\\n\".concat(summaryResult.keywords.map((k)=>\"`\".concat(k, \"`\")).join(\" \"), \"\\n\");\n    }\n    // 파일명 생성 (제목을 파일명으로 변환)\n    const fileName = conversation.title.toLowerCase().replace(/[^a-z0-9가-힣]/g, \"-\").replace(/-+/g, \"-\").replace(/^-|-$/g, \"\").substring(0, 100) + \".md\";\n    // Blob 생성\n    const blob = new Blob([\n        markdownContent\n    ], {\n        type: \"text/markdown;charset=utf-8\"\n    });\n    // 다운로드 링크 생성 및 클릭\n    const url_obj = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url_obj;\n    a.download = fileName;\n    a.click();\n    // URL 객체 해제\n    setTimeout(()=>URL.revokeObjectURL(url_obj), 100);\n}\n/**\r\n * 대화 내용을 JSON 파일로 다운로드합니다.\r\n */ function downloadJsonFile(conversation, summaryResult, url) {\n    var _conversation_metadata;\n    if (!isBrowser()) return;\n    // JSON 파일 내용 생성\n    const jsonContent = JSON.stringify({\n        title: conversation.title,\n        url,\n        summary: summaryResult.summary,\n        keywords: summaryResult.keywords,\n        messages: conversation.messages,\n        metadata: {\n            ...conversation.metadata || {},\n            model: ((_conversation_metadata = conversation.metadata) === null || _conversation_metadata === void 0 ? void 0 : _conversation_metadata.model) || summaryResult.modelUsed || \"gpt-4.1-nano\",\n            savedAt: new Date().toISOString()\n        },\n        createdAt: new Date().toISOString()\n    }, null, 2);\n    // 파일명 생성\n    const fileName = \"\".concat(conversation.title.toLowerCase().replace(/[^a-z0-9가-힣]/g, \"-\"), \"-\").concat(Date.now(), \".json\");\n    // Blob 생성\n    const blob = new Blob([\n        jsonContent\n    ], {\n        type: \"application/json;charset=utf-8\"\n    });\n    // 다운로드 링크 생성 및 클릭\n    const url_obj = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url_obj;\n    a.download = fileName;\n    a.click();\n    // URL 객체 해제\n    setTimeout(()=>URL.revokeObjectURL(url_obj), 100);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9maWxlU3lzdGVtQWNjZXNzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVNBOztDQUVDLEdBQ00sU0FBU0E7SUFDZCxPQUFPLEtBQWtCLElBQ3ZCLHdCQUF3QkMsVUFDeEIseUJBQXlCQTtBQUM3QjtBQUVBOztDQUVDLEdBQ00sU0FBU0M7SUFDZCxPQUFPLGFBQWtCO0FBQzNCO0FBRUE7OztDQUdDLEdBQ00sU0FBU0M7SUFDZCxlQUFlO0lBQ2YsSUFBSSxLQUFrQixFQUFhLEVBS2xDO0lBRUQsa0JBQWtCO0lBQ2xCLElBQUk7UUFDRiw0Q0FBNEM7UUFDNUMsTUFBTU8sV0FBV1QsT0FBT1UsUUFBUSxDQUFDRCxRQUFRO1FBQ3pDLE9BQU9BLFNBQVNFLFFBQVEsQ0FBQyxpQkFDbEJGLFNBQVNHLFFBQVEsQ0FBQyxrQkFDbEIsZUFBZTtRQUNmSCxhQUFhLHFCQUNiQSxhQUFhO0lBQ3RCLEVBQUUsT0FBT0ksT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMscURBQXFEQTtRQUNuRSxvQ0FBb0M7UUFDcEMsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFLGlCQUNwQkMsVUFBNEI7UUFDNUJDLFlBQUFBLGlFQUFxQjtJQUVyQixNQUFNQyxVQUFnRCxDQUFDO0lBQ3ZELElBQUlELFdBQVc7UUFDYkMsUUFBUUMsSUFBSSxHQUFHO0lBQ2pCO0lBRUEsZ0JBQWdCO0lBQ2hCLElBQUksTUFBT0gsV0FBV0ksZUFBZSxDQUFDRixhQUFjLFdBQVc7UUFDN0QsT0FBTztJQUNUO0lBRUEsUUFBUTtJQUNSLElBQUksTUFBT0YsV0FBV0ssaUJBQWlCLENBQUNILGFBQWMsV0FBVztRQUMvRCxPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLGVBQWVJLG1CQUNwQkMsT0FBZTtRQUNmTCxVQUFBQSxpRUFNSSxDQUFDO0lBRUwsSUFBSSxDQUFDbkIsK0JBQStCO1FBQ2xDZSxRQUFRRCxL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QUFlLENBQUNWLFVBQVU7QUFDakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2ZpbGVTeXN0ZW1BY2Nlc3MudHM/MzZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGF0TWVzc2FnZSB9IGZyb20gJ0AvdHlwZXMnO1xyXG5cclxuLy8g64K067aAIO2DgOyehSDsoJXsnZggKOyekOyytCBTdW1tYXJ5UmVzdWx0IOygleydmClcclxuaW50ZXJmYWNlIFN1bW1hcnlEYXRhIHtcclxuICBzdW1tYXJ5OiBzdHJpbmc7XHJcbiAga2V5d29yZHM6IHN0cmluZ1tdO1xyXG4gIG1vZGVsVXNlZD86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbGUgU3lzdGVtIEFjY2VzcyBBUEkg7KeA7JuQIOyXrOu2gOulvCDtmZXsnbjtlanri4jri6QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlU3lzdGVtQWNjZXNzU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBcclxuICAgICdzaG93U2F2ZUZpbGVQaWNrZXInIGluIHdpbmRvdyAmJiBcclxuICAgICdzaG93RGlyZWN0b3J5UGlja2VyJyBpbiB3aW5kb3c7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDruIzrnbzsmrDsoIAg7ZmY6rK97J247KeAIO2ZleyduO2VqeuLiOuLpC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXIoKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG4vKipcclxuICogVmVyY2VsIOuwsO2PrCDtmZjqsr3sl5DshJwg7Iuk7ZaJIOykkeyduOyngCDtmZXsnbjtlanri4jri6QuXHJcbiAqIO2BtOudvOydtOyWuO2KuCwg7ISc67KEIOyCrOydtOuTnCDrqqjrkZDsl5DshJwg7JWI7KCV7KCB7Jy866GcIOuPmeyeke2VmOuPhOuhnSDsiJjsoJVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZlcmNlbEVudigpOiBib29sZWFuIHtcclxuICAvLyDshJzrsoQg7IKs7J2065Oc7JeQ7ISc7J2YIO2ZleyduFxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gcHJvY2Vzcy5lbnYg6rCS7Jy866GcIO2ZleyduCAo7ISc67KEIOyCrOydtOuTnClcclxuICAgIHJldHVybiBCb29sZWFuKHByb2Nlc3MuZW52LlZFUkNFTCA9PT0gJzEnIHx8IFxyXG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfRU5WID09PSAncHJvZHVjdGlvbicgfHwgXHJcbiAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTCA9PT0gJzEnKTtcclxuICB9IFxyXG4gIFxyXG4gIC8vIO2BtOudvOydtOyWuO2KuCDsgqzsnbTrk5zsl5DshJzsnZgg7ZmV7J24XHJcbiAgdHJ5IHtcclxuICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZeycvOuhnCDtmZXsnbggKO2BtOudvOydtOyWuO2KuCDsgqzsnbTrk5wpXHJcbiAgICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcclxuICAgIHJldHVybiBob3N0bmFtZS5pbmNsdWRlcygndmVyY2VsLmFwcCcpIHx8IFxyXG4gICAgICAgICAgIGhvc3RuYW1lLmVuZHNXaXRoKCcudmVyY2VsLmFwcCcpIHx8IFxyXG4gICAgICAgICAgIC8vIOuLpOuluCDtlITroZzrjZXshZgg64+E66mU7J2465OkXHJcbiAgICAgICAgICAgaG9zdG5hbWUgPT09ICdwbWtwcm9qZWN0LnNpdGUnIHx8IFxyXG4gICAgICAgICAgIGhvc3RuYW1lID09PSAnd3d3LnBta3Byb2plY3Quc2l0ZSc7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIFZlcmNlbCBlbnZpcm9ubWVudCBvbiBjbGllbnQgc2lkZTonLCBlcnJvcik7XHJcbiAgICAvLyDsl5Drn6wg67Cc7IOdIOyLnCDslYjsoITtlZjqsowgdHJ1ZSDrsJjtmZggKOuwsO2PrCDtmZjqsr3snLzroZwg7Leo6riJKVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICog7YyM7J28IOyLnOyKpO2FnCDsk7DquLAg6raM7ZWc7J2EIO2ZleyduO2VqeuLiOuLpC5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQZXJtaXNzaW9uKFxyXG4gIGZpbGVIYW5kbGU6IEZpbGVTeXN0ZW1IYW5kbGUsIFxyXG4gIHJlYWRXcml0ZTogYm9vbGVhbiA9IGZhbHNlXHJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGNvbnN0IG9wdGlvbnM6IEZpbGVTeXN0ZW1IYW5kbGVQZXJtaXNzaW9uRGVzY3JpcHRvciA9IHt9O1xyXG4gIGlmIChyZWFkV3JpdGUpIHtcclxuICAgIG9wdGlvbnMubW9kZSA9ICdyZWFkd3JpdGUnO1xyXG4gIH1cclxuICBcclxuICAvLyDsnbTrr7gg6raM7ZWc7J20IOyeiOuKlOyngCDtmZXsnbhcclxuICBpZiAoKGF3YWl0IGZpbGVIYW5kbGUucXVlcnlQZXJtaXNzaW9uKG9wdGlvbnMpKSA9PT0gJ2dyYW50ZWQnKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgXHJcbiAgLy8g6raM7ZWcIOyalOyyrVxyXG4gIGlmICgoYXdhaXQgZmlsZUhhbmRsZS5yZXF1ZXN0UGVybWlzc2lvbihvcHRpb25zKSkgPT09ICdncmFudGVkJykge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIO2MjOydvCDsoIDsnqUg64uk7J207Ja866Gc6re466W8IO2RnOyLnO2VmOqzoCDtjIzsnbzsnYQg7KCA7J6l7ZWp64uI64ukLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVGaWxlV2l0aFBpY2tlcihcclxuICBjb250ZW50OiBzdHJpbmcsIFxyXG4gIG9wdGlvbnM6IHtcclxuICAgIGZpbGVOYW1lPzogc3RyaW5nO1xyXG4gICAgZmlsZUV4dGVuc2lvbj86IHN0cmluZztcclxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xyXG4gICAgc3RhcnRJbj86ICdkb2N1bWVudHMnIHwgJ2Rlc2t0b3AnIHwgJ2Rvd25sb2FkcycgfCAncGljdHVyZXMnIHwgJ211c2ljJyB8IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGU7XHJcbiAgICBtaW1lVHlwZT86IHN0cmluZztcclxuICB9ID0ge31cclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFpc0ZpbGVTeXN0ZW1BY2Nlc3NTdXBwb3J0ZWQoKSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRmlsZSBTeXN0ZW0gQWNjZXNzIEFQSeqwgCDsp4Dsm5DrkJjsp4Ag7JWK64qUIOu4jOudvOyasOyggOyeheuLiOuLpC4nKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgeyBcclxuICAgIGZpbGVOYW1lID0gJ3VudGl0bGVkJywgXHJcbiAgICBmaWxlRXh0ZW5zaW9uID0gJy50eHQnLFxyXG4gICAgZGVzY3JpcHRpb24gPSAnVGV4dCBkb2N1bWVudHMnLFxyXG4gICAgc3RhcnRJbiA9ICdkb2N1bWVudHMnLFxyXG4gICAgbWltZVR5cGUgPSAndGV4dC9wbGFpbidcclxuICB9ID0gb3B0aW9ucztcclxuICBcclxuICBjb25zdCBzdWdnZXN0ZWROYW1lID0gZmlsZU5hbWUuZW5kc1dpdGgoZmlsZUV4dGVuc2lvbikgXHJcbiAgICA/IGZpbGVOYW1lIFxyXG4gICAgOiBgJHtmaWxlTmFtZX0ke2ZpbGVFeHRlbnNpb259YDtcclxuICBcclxuICB0cnkge1xyXG4gICAgLy8g7YyM7J28IOyggOyepSDri6TsnbTslrzroZzqt7gg7ZGc7IucXHJcbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB3aW5kb3cuc2hvd1NhdmVGaWxlUGlja2VyKHtcclxuICAgICAgc3VnZ2VzdGVkTmFtZSxcclxuICAgICAgdHlwZXM6IFt7XHJcbiAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgYWNjZXB0OiB7XHJcbiAgICAgICAgICBbbWltZVR5cGVdOiBbZmlsZUV4dGVuc2lvbl0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfV0sXHJcbiAgICAgIHN0YXJ0SW5cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyDtjIzsnbwg7JOw6riwIOq2jO2VnCDtmZXsnbhcclxuICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSBhd2FpdCB2ZXJpZnlQZXJtaXNzaW9uKGhhbmRsZSwgdHJ1ZSk7XHJcbiAgICBpZiAoIWhhc1Blcm1pc3Npb24pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCftjIzsnbwg7JOw6riwIOq2jO2VnOydtCDqsbDrtoDrkJjsl4jsirXri4jri6QuJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIO2MjOydvCDsk7DquLAg7Iqk7Yq466a8IOyDneyEsVxyXG4gICAgY29uc3Qgd3JpdGFibGUgPSBhd2FpdCBoYW5kbGUuY3JlYXRlV3JpdGFibGUoKTtcclxuICAgIFxyXG4gICAgLy8g642w7J207YSwIOyTsOq4sFxyXG4gICAgYXdhaXQgd3JpdGFibGUud3JpdGUoY29udGVudCk7XHJcbiAgICBcclxuICAgIC8vIOyKpO2KuOumvCDri6vquLBcclxuICAgIGF3YWl0IHdyaXRhYmxlLmNsb3NlKCk7XHJcbiAgICBcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCftjIzsnbwg7KCA7J6lIOykkSDsmKTrpZg6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOuUlOugie2GoOumrCDshKDtg50g64uk7J207Ja866Gc6re466W8IO2RnOyLnO2VmOqzoCDshKDtg53rkJwg65SU66CJ7Yag66as7JeQIO2MjOydvOydhCDsoIDsnqXtlanri4jri6QuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZUZpbGVzVG9EaXJlY3RvcnkoXHJcbiAgZmlsZXM6IEFycmF5PHsgXHJcbiAgICBuYW1lOiBzdHJpbmc7IFxyXG4gICAgY29udGVudDogc3RyaW5nOyBcclxuICAgIHN1YkZvbGRlcj86IHN0cmluZztcclxuICB9PixcclxuICBvcHRpb25zOiB7XHJcbiAgICBzdGFydEluPzogJ2RvY3VtZW50cycgfCAnZGVza3RvcCcgfCAnZG93bmxvYWRzJyB8IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGU7XHJcbiAgfSA9IHt9XHJcbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBzYXZlZEZpbGVzOiBzdHJpbmdbXSB9PiB7XHJcbiAgaWYgKCFpc0ZpbGVTeXN0ZW1BY2Nlc3NTdXBwb3J0ZWQoKSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRmlsZSBTeXN0ZW0gQWNjZXNzIEFQSeqwgCDsp4Dsm5DrkJjsp4Ag7JWK64qUIOu4jOudvOyasOyggOyeheuLiOuLpC4nKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBzYXZlZEZpbGVzOiBbXSB9O1xyXG4gIH1cclxuICBcclxuICBjb25zdCB7IHN0YXJ0SW4gPSAnZG9jdW1lbnRzJyB9ID0gb3B0aW9ucztcclxuICBcclxuICB0cnkge1xyXG4gICAgLy8g65SU66CJ7Yag66asIOyEoO2DnSDri6TsnbTslrzroZzqt7gg7ZGc7IucXHJcbiAgICBjb25zdCBkaXJIYW5kbGUgPSBhd2FpdCB3aW5kb3cuc2hvd0RpcmVjdG9yeVBpY2tlcih7XHJcbiAgICAgIHN0YXJ0SW4sXHJcbiAgICAgIGlkOiAnb2JzaWRpYW4tdmF1bHQtc2VsZWN0b3InLFxyXG4gICAgICBtb2RlOiAncmVhZHdyaXRlJ1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIOuUlOugie2GoOumrCDsk7DquLAg6raM7ZWcIO2ZleyduFxyXG4gICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IGF3YWl0IHZlcmlmeVBlcm1pc3Npb24oZGlySGFuZGxlLCB0cnVlKTtcclxuICAgIGlmICghaGFzUGVybWlzc2lvbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ+uUlOugie2GoOumrCDsk7DquLAg6raM7ZWc7J20IOqxsOu2gOuQmOyXiOyKteuLiOuLpC4nKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgc2F2ZWRGaWxlczogc3RyaW5nW10gPSBbXTtcclxuICAgIFxyXG4gICAgLy8g6rCBIO2MjOydvCDsoIDsnqVcclxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCB0YXJnZXREaXIgPSBkaXJIYW5kbGU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g7ZWY7JyEIO2PtOuNlOqwgCDsp4DsoJXrkJwg6rK97JqwIO2VtOuLuSDtj7TrjZQg7IOd7ISxIOuYkOuKlCDsoJHqt7xcclxuICAgICAgICBpZiAoZmlsZS5zdWJGb2xkZXIpIHtcclxuICAgICAgICAgIGNvbnN0IHN1YkZvbGRlcnMgPSBmaWxlLnN1YkZvbGRlci5zcGxpdCgnLycpO1xyXG4gICAgICAgICAgZm9yIChjb25zdCBmb2xkZXIgb2Ygc3ViRm9sZGVycykge1xyXG4gICAgICAgICAgICBpZiAoIWZvbGRlcikgY29udGludWU7XHJcbiAgICAgICAgICAgIHRhcmdldERpciA9IGF3YWl0IHRhcmdldERpci5nZXREaXJlY3RvcnlIYW5kbGUoZm9sZGVyLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g7YyM7J28IO2VuOuTpCDsg53shLFcclxuICAgICAgICBjb25zdCBmaWxlSGFuZGxlID0gYXdhaXQgdGFyZ2V0RGlyLmdldEZpbGVIYW5kbGUoZmlsZS5uYW1lLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDtjIzsnbwg7JOw6riwIOyKpO2KuOumvCDsg53shLFcclxuICAgICAgICBjb25zdCB3cml0YWJsZSA9IGF3YWl0IGZpbGVIYW5kbGUuY3JlYXRlV3JpdGFibGUoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDrjbDsnbTthLAg7JOw6riwXHJcbiAgICAgICAgYXdhaXQgd3JpdGFibGUud3JpdGUoZmlsZS5jb250ZW50KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDsiqTtirjrprwg64ur6riwXHJcbiAgICAgICAgYXdhaXQgd3JpdGFibGUuY2xvc2UoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDsoIDsnqXrkJwg7YyM7J28IOqyveuhnCDstpTqsIBcclxuICAgICAgICBzYXZlZEZpbGVzLnB1c2goZmlsZS5zdWJGb2xkZXIgPyBgJHtmaWxlLnN1YkZvbGRlcn0vJHtmaWxlLm5hbWV9YCA6IGZpbGUubmFtZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGZpbGVFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYO2MjOydvCDsoIDsnqUg7KSRIOyYpOulmCAoJHtmaWxlLm5hbWV9KTpgLCBmaWxlRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7IFxyXG4gICAgICBzdWNjZXNzOiBzYXZlZEZpbGVzLmxlbmd0aCA+IDAsIFxyXG4gICAgICBzYXZlZEZpbGVzIFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign65SU66CJ7Yag66asIOyggOyepSDspJEg7Jik66WYOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBzYXZlZEZpbGVzOiBbXSB9O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOyYteyLnOuUlOyWuCDrs7ztirjsl5Ag64yA7ZmUIOuCtOyaqeydhCDsoIDsnqXtlanri4jri6QuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZUNvbnZlcnNhdGlvblRvT2JzaWRpYW5WYXVsdChcclxuICBjb252ZXJzYXRpb246IHtcclxuICAgIHRpdGxlOiBzdHJpbmc7XHJcbiAgICBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXTtcclxuICAgIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICB9LFxyXG4gIHN1bW1hcnlSZXN1bHQ6IFN1bW1hcnlEYXRhLFxyXG4gIHJhd1RleHQ6IHN0cmluZyxcclxuICB1cmw6IHN0cmluZ1xyXG4pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZmlsZXM6IHN0cmluZ1tdIH0+IHtcclxuICBpZiAoIWlzRmlsZVN5c3RlbUFjY2Vzc1N1cHBvcnRlZCgpKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGaWxlIFN5c3RlbSBBY2Nlc3MgQVBJ6rCAIOyngOybkOuQmOyngCDslYrripQg67iM65287Jqw7KCA7J6F64uI64ukLicpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGZpbGVzOiBbXSB9O1xyXG4gIH1cclxuICBcclxuICB0cnkge1xyXG4gICAgLy8g7YyM7J2866qFIOyDneyEsSAo7KCc66qp7J2EIO2MjOydvOuqheycvOuhnCDrs4DtmZgpXHJcbiAgICBjb25zdCBiYXNlRmlsZU5hbWUgPSBjb252ZXJzYXRpb24udGl0bGVcclxuICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICAgLnJlcGxhY2UoL1teYS16MC056rCALe2eo10vZywgJy0nKVxyXG4gICAgICAucmVwbGFjZSgvLSsvZywgJy0nKVxyXG4gICAgICAucmVwbGFjZSgvXi18LSQvZywgJycpXHJcbiAgICAgIC5zdWJzdHJpbmcoMCwgMTAwKTtcclxuICAgIFxyXG4gICAgY29uc3QgbWFya2Rvd25GaWxlTmFtZSA9IGAke2Jhc2VGaWxlTmFtZX0ubWRgO1xyXG4gICAgY29uc3QgdGV4dEZpbGVOYW1lID0gYCR7YmFzZUZpbGVOYW1lfS1vcmlnaW5hbC50eHRgO1xyXG4gICAgY29uc3QganNvbkZpbGVOYW1lID0gYCR7YmFzZUZpbGVOYW1lfS0ke0RhdGUubm93KCl9Lmpzb25gO1xyXG4gICAgXHJcbiAgICAvLyDtg5zqt7gg66qp66GdIOykgOu5hCAo7JqU7JW97JeQ7IScIOy2lOy2nO2VnCDtgqTsm4zrk5wgKyBDaGF0R1BUIOuqqOuNuClcclxuICAgIGNvbnN0IHRhZ3MgPSBbXHJcbiAgICAgIC4uLihzdW1tYXJ5UmVzdWx0LmtleXdvcmRzIHx8IFtdKSxcclxuICAgICAgY29udmVyc2F0aW9uLm1ldGFkYXRhPy5tb2RlbCB8fCBzdW1tYXJ5UmVzdWx0Lm1vZGVsVXNlZCB8fCAnZ3B0LTQuMS1uYW5vJ1xyXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7IC8vIOu5iCDqsJIg7KCc6rGwXHJcbiAgICBcclxuICAgIC8vIFlBTUwg7ZSE66Gg7Yq466ek7YSwIOyDneyEsVxyXG4gICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBgLS0tXHJcbnRpdGxlOiAke2NvbnZlcnNhdGlvbi50aXRsZX1cclxuZGF0ZTogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XHJcbnNvdXJjZTogJHt1cmx9XHJcbnRhZ3M6IFske3RhZ3MubWFwKHRhZyA9PiBgXCIke3RhZ31cImApLmpvaW4oJywgJyl9XVxyXG5tb2RlbDogJHtjb252ZXJzYXRpb24ubWV0YWRhdGE/Lm1vZGVsIHx8IHN1bW1hcnlSZXN1bHQubW9kZWxVc2VkIHx8ICdncHQtNC4xLW5hbm8nfVxyXG4tLS1cclxuXHJcbmA7XHJcbiAgICBcclxuICAgIC8vIOuMgO2ZlCDrgrTsmqnsnYQg66eI7YGs64uk7Jq07Jy866GcIOuzgO2ZmFxyXG4gICAgbGV0IG1hcmtkb3duQ29udGVudCA9IGZyb250bWF0dGVyO1xyXG4gICAgXHJcbiAgICAvLyDrjIDtmZQg64K07JqpIOy2lOqwgFxyXG4gICAgbWFya2Rvd25Db250ZW50ICs9IGAjICR7Y29udmVyc2F0aW9uLnRpdGxlfVxcblxcbmA7XHJcbiAgICBcclxuICAgIC8vIFVSTOqzvCDrgqDsp5wg7KCV67O0IOy2lOqwgFxyXG4gICAgbWFya2Rvd25Db250ZW50ICs9IGA+IFvsm5Drs7ggVVJMXSgke3VybH0pXFxuXFxuYDtcclxuICAgIG1hcmtkb3duQ29udGVudCArPSBgPiDsoIDsnqUg7Iuc6rCEOiAke25ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoJ2tvLUtSJyl9XFxuXFxuYDtcclxuICAgIFxyXG4gICAgaWYgKHRhZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICBtYXJrZG93bkNvbnRlbnQgKz0gYD4g7YOc6re4OiAke3RhZ3Muam9pbignLCAnKX1cXG5cXG5gO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBtYXJrZG93bkNvbnRlbnQgKz0gYC0tLVxcblxcbmA7XHJcbiAgICBcclxuICAgIC8vIOyCrOyaqeyekC3slrTsi5zsiqTthLTtirgg64yA7ZmUIOuCtOyaqeydhCDrp4jtgazri6TsmrTsnLzroZwg7Y+s66e37YyFXHJcbiAgICBjb252ZXJzYXRpb24ubWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgaXNVc2VyID0gbWVzc2FnZS5yb2xlID09PSAndXNlcic7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VIZWFkZXIgPSBpc1VzZXIgPyAnIyMg8J+RpCDsgqzsmqnsnpAnIDogJyMjIPCfpJYgYXNzaXN0YW50JztcclxuICAgICAgXHJcbiAgICAgIC8vIOyXre2VoOqzvCDrgrTsmqnsnYQg6rWs67aE7ZWY7JesIO2RnOyLnFxyXG4gICAgICBtYXJrZG93bkNvbnRlbnQgKz0gYCR7bWVzc2FnZUhlYWRlcn1cXG5cXG4ke21lc3NhZ2UuY29udGVudH1cXG5cXG5gO1xyXG4gICAgICBcclxuICAgICAgLy8g66eI7KeA66eJIOuplOyLnOyngOqwgCDslYTri4jrqbQg6rWs67aE7ISgIOy2lOqwgFxyXG4gICAgICBpZiAoaW5kZXggPCBjb252ZXJzYXRpb24ubWVzc2FnZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIG1hcmtkb3duQ29udGVudCArPSBgLS0tXFxuXFxuYDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIOyalOyVvSDshLnshZgg7LaU6rCAXHJcbiAgICBtYXJrZG93bkNvbnRlbnQgKz0gYFxcblxcbi0tLVxcblxcbiMjIPCfkqEg7JqU7JW9XFxuXFxuJHtzdW1tYXJ5UmVzdWx0LnN1bW1hcnl9XFxuYDtcclxuICAgIFxyXG4gICAgLy8g7YKk7JuM65OcIOyEueyFmCDstpTqsIBcclxuICAgIGlmIChzdW1tYXJ5UmVzdWx0LmtleXdvcmRzICYmIHN1bW1hcnlSZXN1bHQua2V5d29yZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBtYXJrZG93bkNvbnRlbnQgKz0gYFxcbiMjIPCflJEg7YKk7JuM65OcXFxuXFxuJHtzdW1tYXJ5UmVzdWx0LmtleXdvcmRzLm1hcChrID0+IGBcXGAke2t9XFxgYCkuam9pbignICcpfVxcbmA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEpTT04g7YyM7J28IOuCtOyaqSDsg53shLFcclxuICAgIGNvbnN0IGpzb25Db250ZW50ID0gSlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgIHtcclxuICAgICAgICB0aXRsZTogY29udmVyc2F0aW9uLnRpdGxlLFxyXG4gICAgICAgIHVybCxcclxuICAgICAgICBzdW1tYXJ5OiBzdW1tYXJ5UmVzdWx0LnN1bW1hcnksXHJcbiAgICAgICAga2V5d29yZHM6IHN1bW1hcnlSZXN1bHQua2V5d29yZHMsXHJcbiAgICAgICAgbWVzc2FnZXM6IGNvbnZlcnNhdGlvbi5tZXNzYWdlcyxcclxuICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgLi4uKGNvbnZlcnNhdGlvbi5tZXRhZGF0YSB8fCB7fSksXHJcbiAgICAgICAgICBtb2RlbDogY29udmVyc2F0aW9uLm1ldGFkYXRhPy5tb2RlbCB8fCBzdW1tYXJ5UmVzdWx0Lm1vZGVsVXNlZCB8fCAnZ3B0LTQuMS1uYW5vJyxcclxuICAgICAgICAgIHNhdmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSxcclxuICAgICAgbnVsbCxcclxuICAgICAgMlxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8g7YyM7J28IOyggOyepe2VoCDspIDruYRcclxuICAgIGNvbnN0IGZpbGVzID0gW1xyXG4gICAgICB7IFxyXG4gICAgICAgIG5hbWU6IG1hcmtkb3duRmlsZU5hbWUsIFxyXG4gICAgICAgIGNvbnRlbnQ6IG1hcmtkb3duQ29udGVudCwgXHJcbiAgICAgICAgc3ViRm9sZGVyOiAnQ2hhdEdQVCdcclxuICAgICAgfSxcclxuICAgICAgeyBcclxuICAgICAgICBuYW1lOiB0ZXh0RmlsZU5hbWUsIFxyXG4gICAgICAgIGNvbnRlbnQ6IHJhd1RleHQsIFxyXG4gICAgICAgIHN1YkZvbGRlcjogJ0NoYXRHUFQnXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgXHJcbiAgICAgICAgbmFtZToganNvbkZpbGVOYW1lLCBcclxuICAgICAgICBjb250ZW50OiBqc29uQ29udGVudCwgXHJcbiAgICAgICAgc3ViRm9sZGVyOiAnX2RhdGEvY29udmVyc2F0aW9ucydcclxuICAgICAgfVxyXG4gICAgXTtcclxuICAgIFxyXG4gICAgLy8g65SU66CJ7Yag66asIOyEoO2DnSDri6TsnbTslrzroZzqt7gg7ZGc7IucIOuwjyDtjIzsnbwg7KCA7J6lXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYXZlRmlsZXNUb0RpcmVjdG9yeShmaWxlcywgeyBzdGFydEluOiAnZG9jdW1lbnRzJyB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXHJcbiAgICAgIGZpbGVzOiByZXN1bHQuc2F2ZWRGaWxlc1xyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign7Ji17Iuc65SU7Ja4IOyggOyepSDspJEg7Jik66WYOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBmaWxlczogW10gfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDrjIDtmZQg64K07Jqp7J2EIOuniO2BrOuLpOyatCDtjIzsnbzroZwg64uk7Jq066Gc65Oc7ZWp64uI64ukLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkTWFya2Rvd25GaWxlKFxyXG4gIGNvbnZlcnNhdGlvbjoge1xyXG4gICAgdGl0bGU6IHN0cmluZztcclxuICAgIG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdO1xyXG4gICAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG4gIH0sXHJcbiAgc3VtbWFyeVJlc3VsdDogU3VtbWFyeURhdGEsXHJcbiAgdXJsOiBzdHJpbmdcclxuKTogdm9pZCB7XHJcbiAgaWYgKCFpc0Jyb3dzZXIoKSkgcmV0dXJuO1xyXG5cclxuICAvLyDtg5zqt7gg66qp66GdIOykgOu5hCAo7JqU7JW97JeQ7IScIOy2lOy2nO2VnCDtgqTsm4zrk5wgKyBDaGF0R1BUIOuqqOuNuClcclxuICBjb25zdCB0YWdzID0gW1xyXG4gICAgLi4uKHN1bW1hcnlSZXN1bHQua2V5d29yZHMgfHwgW10pLFxyXG4gICAgY29udmVyc2F0aW9uLm1ldGFkYXRhPy5tb2RlbCB8fCBzdW1tYXJ5UmVzdWx0Lm1vZGVsVXNlZCB8fCAnZ3B0LTQuMS1uYW5vJ1xyXG4gIF0uZmlsdGVyKEJvb2xlYW4pOyAvLyDruYgg6rCSIOygnOqxsFxyXG4gIFxyXG4gIC8vIFlBTUwg7ZSE66Gg7Yq466ek7YSwIOyDneyEsVxyXG4gIGNvbnN0IGZyb250bWF0dGVyID0gYC0tLVxyXG50aXRsZTogJHtjb252ZXJzYXRpb24udGl0bGV9XHJcbmRhdGU6ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxyXG5zb3VyY2U6ICR7dXJsfVxyXG50YWdzOiBbJHt0YWdzLm1hcCh0YWcgPT4gYFwiJHt0YWd9XCJgKS5qb2luKCcsICcpfV1cclxubW9kZWw6ICR7Y29udmVyc2F0aW9uLm1ldGFkYXRhPy5tb2RlbCB8fCBzdW1tYXJ5UmVzdWx0Lm1vZGVsVXNlZCB8fCAnZ3B0LTQuMS1uYW5vJ31cclxuLS0tXHJcblxyXG5gO1xyXG4gIFxyXG4gIC8vIOuMgO2ZlCDrgrTsmqnsnYQg66eI7YGs64uk7Jq07Jy866GcIOuzgO2ZmFxyXG4gIGxldCBtYXJrZG93bkNvbnRlbnQgPSBmcm9udG1hdHRlcjtcclxuICBcclxuICAvLyDrjIDtmZQg64K07JqpIOy2lOqwgFxyXG4gIG1hcmtkb3duQ29udGVudCArPSBgIyAke2NvbnZlcnNhdGlvbi50aXRsZX1cXG5cXG5gO1xyXG4gIFxyXG4gIC8vIFVSTOqzvCDrgqDsp5wg7KCV67O0IOy2lOqwgFxyXG4gIG1hcmtkb3duQ29udGVudCArPSBgPiBb7JuQ67O4IFVSTF0oJHt1cmx9KVxcblxcbmA7XHJcbiAgbWFya2Rvd25Db250ZW50ICs9IGA+IOyggOyepSDsi5zqsIQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygna28tS1InKX1cXG5cXG5gO1xyXG4gIFxyXG4gIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcclxuICAgIG1hcmtkb3duQ29udGVudCArPSBgPiDtg5zqt7g6ICR7dGFncy5qb2luKCcsICcpfVxcblxcbmA7XHJcbiAgfVxyXG4gIFxyXG4gIG1hcmtkb3duQ29udGVudCArPSBgLS0tXFxuXFxuYDtcclxuICBcclxuICAvLyDsgqzsmqnsnpAt7Ja07Iuc7Iqk7YS07Yq4IOuMgO2ZlCDrgrTsmqnsnYQg66eI7YGs64uk7Jq07Jy866GcIO2PrOunt+2MhVxyXG4gIGNvbnZlcnNhdGlvbi5tZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlLCBpbmRleCkgPT4ge1xyXG4gICAgY29uc3QgaXNVc2VyID0gbWVzc2FnZS5yb2xlID09PSAndXNlcic7XHJcbiAgICBjb25zdCBtZXNzYWdlSGVhZGVyID0gaXNVc2VyID8gJyMjIPCfkaQg7IKs7Jqp7J6QJyA6ICcjIyDwn6SWIGFzc2lzdGFudCc7XHJcbiAgICBcclxuICAgIC8vIOyXre2VoOqzvCDrgrTsmqnsnYQg6rWs67aE7ZWY7JesIO2RnOyLnFxyXG4gICAgbWFya2Rvd25Db250ZW50ICs9IGAke21lc3NhZ2VIZWFkZXJ9XFxuXFxuJHttZXNzYWdlLmNvbnRlbnR9XFxuXFxuYDtcclxuICAgIFxyXG4gICAgLy8g66eI7KeA66eJIOuplOyLnOyngOqwgCDslYTri4jrqbQg6rWs67aE7ISgIOy2lOqwgFxyXG4gICAgaWYgKGluZGV4IDwgY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgbWFya2Rvd25Db250ZW50ICs9IGAtLS1cXG5cXG5gO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIOyalOyVvSDshLnshZgg7LaU6rCAXHJcbiAgbWFya2Rvd25Db250ZW50ICs9IGBcXG5cXG4tLS1cXG5cXG4jIyDwn5KhIOyalOyVvVxcblxcbiR7c3VtbWFyeVJlc3VsdC5zdW1tYXJ5fVxcbmA7XHJcbiAgXHJcbiAgLy8g7YKk7JuM65OcIOyEueyFmCDstpTqsIBcclxuICBpZiAoc3VtbWFyeVJlc3VsdC5rZXl3b3JkcyAmJiBzdW1tYXJ5UmVzdWx0LmtleXdvcmRzLmxlbmd0aCA+IDApIHtcclxuICAgIG1hcmtkb3duQ29udGVudCArPSBgXFxuIyMg8J+UkSDtgqTsm4zrk5xcXG5cXG4ke3N1bW1hcnlSZXN1bHQua2V5d29yZHMubWFwKGsgPT4gYFxcYCR7a31cXGBgKS5qb2luKCcgJyl9XFxuYDtcclxuICB9XHJcblxyXG4gIC8vIO2MjOydvOuqhSDsg53shLEgKOygnOuqqeydhCDtjIzsnbzrqoXsnLzroZwg67OA7ZmYKVxyXG4gIGNvbnN0IGZpbGVOYW1lID0gY29udmVyc2F0aW9uLnRpdGxlXHJcbiAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgLnJlcGxhY2UoL1teYS16MC056rCALe2eo10vZywgJy0nKVxyXG4gICAgLnJlcGxhY2UoLy0rL2csICctJylcclxuICAgIC5yZXBsYWNlKC9eLXwtJC9nLCAnJylcclxuICAgIC5zdWJzdHJpbmcoMCwgMTAwKSArICcubWQnO1xyXG5cclxuICAvLyBCbG9iIOyDneyEsVxyXG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbbWFya2Rvd25Db250ZW50XSwgeyB0eXBlOiAndGV4dC9tYXJrZG93bjtjaGFyc2V0PXV0Zi04JyB9KTtcclxuICBcclxuICAvLyDri6TsmrTroZzrk5wg66eB7YGsIOyDneyEsSDrsI8g7YG066atXHJcbiAgY29uc3QgdXJsX29iaiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICBhLmhyZWYgPSB1cmxfb2JqO1xyXG4gIGEuZG93bmxvYWQgPSBmaWxlTmFtZTtcclxuICBhLmNsaWNrKCk7XHJcbiAgXHJcbiAgLy8gVVJMIOqwneyytCDtlbTsoJxcclxuICBzZXRUaW1lb3V0KCgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwodXJsX29iaiksIDEwMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDrjIDtmZQg64K07Jqp7J2EIEpTT04g7YyM7J2866GcIOuLpOyatOuhnOuTnO2VqeuLiOuLpC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZEpzb25GaWxlKFxyXG4gIGNvbnZlcnNhdGlvbjoge1xyXG4gICAgdGl0bGU6IHN0cmluZztcclxuICAgIG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdO1xyXG4gICAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG4gIH0sXHJcbiAgc3VtbWFyeVJlc3VsdDogU3VtbWFyeURhdGEsXHJcbiAgdXJsOiBzdHJpbmdcclxuKTogdm9pZCB7XHJcbiAgaWYgKCFpc0Jyb3dzZXIoKSkgcmV0dXJuO1xyXG5cclxuICAvLyBKU09OIO2MjOydvCDrgrTsmqkg7IOd7ISxXHJcbiAgY29uc3QganNvbkNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShcclxuICAgIHtcclxuICAgICAgdGl0bGU6IGNvbnZlcnNhdGlvbi50aXRsZSxcclxuICAgICAgdXJsLFxyXG4gICAgICBzdW1tYXJ5OiBzdW1tYXJ5UmVzdWx0LnN1bW1hcnksXHJcbiAgICAgIGtleXdvcmRzOiBzdW1tYXJ5UmVzdWx0LmtleXdvcmRzLFxyXG4gICAgICBtZXNzYWdlczogY29udmVyc2F0aW9uLm1lc3NhZ2VzLFxyXG4gICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgIC4uLihjb252ZXJzYXRpb24ubWV0YWRhdGEgfHwge30pLFxyXG4gICAgICAgIG1vZGVsOiBjb252ZXJzYXRpb24ubWV0YWRhdGE/Lm1vZGVsIHx8IHN1bW1hcnlSZXN1bHQubW9kZWxVc2VkIHx8ICdncHQtNC4xLW5hbm8nLFxyXG4gICAgICAgIHNhdmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9LFxyXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfSxcclxuICAgIG51bGwsXHJcbiAgICAyXHJcbiAgKTtcclxuXHJcbiAgLy8g7YyM7J2866qFIOyDneyEsVxyXG4gIGNvbnN0IGZpbGVOYW1lID0gYCR7Y29udmVyc2F0aW9uLnRpdGxlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTnqsIAt7Z6jXS9nLCAnLScpfS0ke0RhdGUubm93KCl9Lmpzb25gO1xyXG5cclxuICAvLyBCbG9iIOyDneyEsVxyXG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbanNvbkNvbnRlbnRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnIH0pO1xyXG4gIFxyXG4gIC8vIOuLpOyatOuhnOuTnCDrp4Htgawg7IOd7ISxIOuwjyDtgbTrpq1cclxuICBjb25zdCB1cmxfb2JqID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gIGEuaHJlZiA9IHVybF9vYmo7XHJcbiAgYS5kb3dubG9hZCA9IGZpbGVOYW1lO1xyXG4gIGEuY2xpY2soKTtcclxuICBcclxuICAvLyBVUkwg6rCd7LK0IO2VtOygnFxyXG4gIHNldFRpbWVvdXQoKCkgPT4gVVJMLnJldm9rZU9iamVjdFVSTCh1cmxfb2JqKSwgMTAwKTtcclxufSAiXSwibmFtZXMiOlsiaXNGaWxlU3lzdGVtQWNjZXNzU3VwcG9ydGVkIiwid2luZG93IiwiaXNCcm93c2VyIiwiaXNWZXJjZWxFbnYiLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIlZFUkNFTCIsIk5FWFRfUFVCTElDX1ZFUkNFTF9FTlYiLCJORVhUX1BVQkxJQ19WRVJDRUwiLCJob3N0bmFtZSIsImxvY2F0aW9uIiwiaW5jbHVkZXMiLCJlbmRzV2l0aCIsImVycm9yIiwiY29uc29sZSIsInZlcmlmeVBlcm1pc3Npb24iLCJmaWxlSGFuZGxlIiwicmVhZFdyaXRlIiwib3B0aW9ucyIsIm1vZGUiLCJxdWVyeVBlcm1pc3Npb24iLCJyZXF1ZXN0UGVybWlzc2lvbiIsInNhdmVGaWxlV2l0aFBpY2tlciIsImNvbnRlbnQiLCJmaWxlTmFtZSIsImZpbGVFeHRlbnNpb24iLCJkZXNjcmlwdGlvbiIsInN0YXJ0SW4iLCJtaW1lVHlwZSIsInN1Z2dlc3RlZE5hbWUiLCJoYW5kbGUiLCJzaG93U2F2ZUZpbGVQaWNrZXIiLCJ0eXBlcyIsImFjY2VwdCIsImhhc1Blcm1pc3Npb24iLCJFcnJvciIsIndyaXRhYmxlIiwiY3JlYXRlV3JpdGFibGUiLCJ3cml0ZSIsImNsb3NlIiwic2F2ZUZpbGVzVG9EaXJlY3RvcnkiLCJmaWxlcyIsInN1Y2Nlc3MiLCJzYXZlZEZpbGVzIiwiZGlySGFuZGxlIiwic2hvd0RpcmVjdG9yeVBpY2tlciIsImlkIiwiZmlsZSIsInRhcmdldERpciIsInN1YkZvbGRlciIsInN1YkZvbGRlcnMiLCJzcGxpdCIsImZvbGRlciIsImdldERpcmVjdG9yeUhhbmRsZSIsImNyZWF0ZSIsImdldEZpbGVIYW5kbGUiLCJuYW1lIiwicHVzaCIsImZpbGVFcnJvciIsImxlbmd0aCIsInNhdmVDb252ZXJzYXRpb25Ub09ic2lkaWFuVmF1bHQiLCJjb252ZXJzYXRpb24iLCJzdW1tYXJ5UmVzdWx0IiwicmF3VGV4dCIsInVybCIsImJhc2VGaWxlTmFtZSIsInRpdGxlIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwibWFya2Rvd25GaWxlTmFtZSIsInRleHRGaWxlTmFtZSIsImpzb25GaWxlTmFtZSIsIkRhdGUiLCJub3ciLCJ0YWdzIiwia2V5d29yZHMiLCJtZXRhZGF0YSIsIm1vZGVsIiwibW9kZWxVc2VkIiwiZmlsdGVyIiwiZnJvbnRtYXR0ZXIiLCJ0b0lTT1N0cmluZyIsIm1hcCIsInRhZyIsImpvaW4iLCJtYXJrZG93bkNvbnRlbnQiLCJ0b0xvY2FsZVN0cmluZyIsIm1lc3NhZ2VzIiwiZm9yRWFjaCIsIm1lc3NhZ2UiLCJpbmRleCIsImlzVXNlciIsInJvbGUiLCJtZXNzYWdlSGVhZGVyIiwic3VtbWFyeSIsImsiLCJqc29uQ29udGVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzYXZlZEF0IiwiY3JlYXRlZEF0IiwicmVzdWx0IiwiZG93bmxvYWRNYXJrZG93bkZpbGUiLCJibG9iIiwiQmxvYiIsInR5cGUiLCJ1cmxfb2JqIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsImNsaWNrIiwic2V0VGltZW91dCIsInJldm9rZU9iamVjdFVSTCIsImRvd25sb2FkSnNvbkZpbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/fileSystemAccess.ts\n"));

/***/ })

});